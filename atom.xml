<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lian の blogs</title>
  
  <subtitle>Stay hungry,Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lianblogs.cn/"/>
  <updated>2019-08-21T20:21:08.839Z</updated>
  <id>https://lianblogs.cn/</id>
  
  <author>
    <name>Lian S</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://lianblogs.cn/2019/08/21/HTTP/"/>
    <id>https://lianblogs.cn/2019/08/21/HTTP/</id>
    <published>2019-08-21T06:58:25.000Z</published>
    <updated>2019-08-21T20:21:08.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>HTTP协议是基于C/S架构运行在TCP之上请求响应的应用层超文本传输协议</p><p>协议（网络协议）：在同层之间有关通信的规则和约定的集合</p><p>C/S架构：它是客户端和服务器之间所签订的协议</p><h1 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h1><p>典型的HTTP事务处理过程</p><ol><li>客户端与服务器建立链接</li><li>客户端向服务器提出请求</li><li>服务器接受请求，根据请求返回相应的文件作为应答</li><li>客户与服务器关闭连接。</li></ol><p>C/S架构的HTTP连接是一种一次性连接，它限制每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭连接，下次请求再重新建立连接。</p><a id="more"></a><h1 id="请求Request"><a href="#请求Request" class="headerlink" title="请求Request"></a>请求Request</h1><p>HTTP规范定义了7种请求方法，每种请求方法规定了客户和服务器之间不同的信息交换方式，常用的请求方法是GET和POST。</p><h2 id="GET请求头"><a href="#GET请求头" class="headerlink" title="GET请求头"></a>GET请求头</h2><p>GET请求示例</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="regexp">/hello/</span>index.jsp HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="string">Host:</span> localhost</span><br><span class="line">User-<span class="string">Agent:</span> Mozilla<span class="regexp">/5.0 (Windows NT 5.1; rv:5.0) Gecko/</span><span class="number">20100101</span> Firefox/<span class="number">5.0</span></span><br><span class="line"><span class="string">Accept:</span> text<span class="regexp">/html,application/</span>xhtml+xml,application<span class="regexp">/xml;q=0.9,*/</span>*;q=<span class="number">0.8</span></span><br><span class="line">Accept-<span class="string">Language:</span> zh-cn,zh;q=<span class="number">0.5</span></span><br><span class="line">Accept-<span class="string">Encoding:</span> gzip, deflate</span><br><span class="line">Accept-<span class="string">Charset:</span> GB2312,utf<span class="number">-8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line"><span class="string">Connection:</span> keep-alive</span><br><span class="line"><span class="string">Cookie:</span> JSESSIONID=<span class="number">369766</span>FDF6220F7803433C0B2DE36D98</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">Key</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">GET /xx/xx.jsp HTTP/1.1</td><td align="left">请求方式 路径 所用协议/协议版本号</td></tr><tr><td align="left">Host</td><td align="left">请求的主机名为localhost</td></tr><tr><td align="left">User-Agent</td><td align="left">与浏览器和OS（操作系统）相关的信息</td></tr><tr><td align="left">Accept</td><td align="left">客户端可以接收的文档类型</td></tr><tr><td align="left">Accept-Language</td><td align="left">当前客户端支持的语言</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">支持的压缩格式</td></tr><tr><td align="left">Accept-Charset</td><td align="left">客户端支持的编码</td></tr><tr><td align="left">Connection</td><td align="left">客户端支持的链接方式，保持一段时间连接，默认为3000ms</td></tr><tr><td align="left">Cookie</td><td align="left">再次访问时客户端会将Cookie带给服务器</td></tr></tbody></table><h2 id="POST请求头"><a href="#POST请求头" class="headerlink" title="POST请求头"></a>POST请求头</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/hello/index.jsp</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: image/gif, image/jpeg, image/pjpeg, */*</span><br><span class="line"><span class="attribute">Referer</span>: http://localhost:8080/hello/index.jsp</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-cn,en-US;q=0.5</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/4.0 </span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Host</span>: localhost:8080</span><br><span class="line"><span class="attribute">Content-Length</span>: 13</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Cookie</span>: JSESSIONID=E365D980343B9307023A1D271CC48E7D</span><br><span class="line"></span><br><span class="line">keyword=hello</span><br></pre></td></tr></table></figure><table><thead><tr><th>Key</th><th>意义</th></tr></thead><tbody><tr><td>Referer<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></td><td>请求来自哪个页面，从一个页面跳转到另一个页面时会出现</td></tr><tr><td>Content-Type</td><td>表单的数据类型，说明会使用url格式编码<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></td></tr><tr><td>Content-Length</td><td>请求体的长度，就是这里“keyword=hello”的长度<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></td></tr></tbody></table><p>keyword=hello：请求体内容，是在表单中输入的数据，是表单字段的名字</p><h1 id="响应Response"><a href="#响应Response" class="headerlink" title="响应Response"></a>响应Response</h1><p>响应协议格式</p><ol><li>响应首行</li><li>响应头信息</li><li>空行</li><li>响应体</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP<span class="regexp">/1.1 200 OK/</span>/响应首行</span><br><span class="line"><span class="string">Server:</span> Apache-Coyote/<span class="number">1.1</span></span><br><span class="line">Content-<span class="string">Type:</span> text/html;charset=UTF<span class="number">-8</span></span><br><span class="line">Content-<span class="string">Length:</span> <span class="number">724</span></span><br><span class="line">Set-<span class="string">Cookie:</span> JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello</span><br><span class="line"><span class="string">Date:</span> Wed, <span class="number">25</span> Sep <span class="number">2012</span> <span class="number">04</span>:<span class="number">15</span>:<span class="number">03</span> GMT <span class="comment">//以上为响应头信息</span></span><br><span class="line"><span class="comment">//空行</span></span><br><span class="line">html code <span class="comment">//响应体</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Key</th><th>意义</th></tr></thead><tbody><tr><td>HTTP/1.1 200 OK</td><td>响应协议为HTTP1.1，状态码为200，表示请求成功，OK是对状态码的解释</td></tr><tr><td>Server</td><td>服务器的版本信息</td></tr><tr><td>Content-Type</td><td>响应体使用的编码为UTF-8</td></tr><tr><td>Content-Length</td><td>响应体为大小，单位字节</td></tr><tr><td>Set-Cookie</td><td>响应给客户端的Cookie</td></tr><tr><td>Date</td><td>响应的时间</td></tr></tbody></table><h2 id="响应码（应答码）"><a href="#响应码（应答码）" class="headerlink" title="响应码（应答码）"></a>响应码（应答码）</h2><table><thead><tr><th>形式</th><th>类型</th></tr></thead><tbody><tr><td>1XX</td><td>信息类（Information）表示收到Web浏览器请求，正在进一步的处理中</td></tr><tr><td>2XX</td><td>成功类（Successful）表示用户请求被正确接收</td></tr><tr><td>3XX</td><td>重定向类（Redirection）后续的请求地址在本次响应的 Location 域中指明</td></tr><tr><td>4XX</td><td>客户端错误（Client Error）表示客户端提交的请求有错误</td></tr><tr><td>5XX</td><td>服务器错误（Server Error）表示服务器不能完成对请求的处理</td></tr></tbody></table><p>常见响应码</p><ul><li><p>200：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中</p></li><li><p>404：请求的资源没有找到，说明客户端错误的请求了不存在的资源</p></li><li><p>500：请求资源找到了，但服务器内部出现了错误</p></li><li><p>302：重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location，它指定了新请求的URL地址</p></li></ul><h3 id="304响应码"><a href="#304响应码" class="headerlink" title="304响应码"></a>304响应码</h3><p>当用户第一次请求index.html时，服务器会添加一个名为Last-Modified响应头，这个头说明了index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第二次请求index.html时，在请求中包含一个名为If-Modified-Since请求头，它的值就是第一次请求时服务器通过Last-Modified响应头发送给浏览器的值，即index.html最后的修改时间，If-Modified-Since请求头就是在告诉服务器，我这里浏览器缓存的index.html最后修改时间是这个，您看看现在的index.html最后修改时间是不是这个，如果还是，那么您就不用再响应这个index.html内容了，我会把缓存的内容直接显示出来。而服务器端会获取If-Modified-Since值，与index.html的当前最后修改时间比对，如果相同，服务器会发响应码304，表示index.html与浏览器上次缓存的相同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明index.html已经做了修改，服务器会响应200。</p><h1 id="其他响应头"><a href="#其他响应头" class="headerlink" title="其他响应头"></a>其他响应头</h1><h2 id="禁止缓存"><a href="#禁止缓存" class="headerlink" title="禁止缓存"></a>禁止缓存</h2><p>告诉浏览器不要缓存的响应头：</p><ol><li>Expires: -1;</li><li>Cache-Control: no-cache;</li><li>Pragma: no-cache；</li></ol><h2 id="自动刷新响应头"><a href="#自动刷新响应头" class="headerlink" title="自动刷新响应头"></a>自动刷新响应头</h2><ul><li><p>Refresh: 3;url=<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>;</p><p>浏览器会在3秒之后请求<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p></li></ul><h1 id="HTML中指定响应头"><a href="#HTML中指定响应头" class="headerlink" title="HTML中指定响应头"></a>HTML中指定响应头</h1><p>在HTMl页面中可以使用</p><p><code>&lt;meta http-equiv=&quot;&quot; content=&quot;&quot;&gt;</code></p><p>来指定响应头，例如在index.html页面中给出</p><p><code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;3;url=http://http://www.google.com&quot;&gt;</code><br>表示浏览器只会显示index.html页面3秒，然后自动跳转到<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">referer这个单词其实是早期的HTTP规范的拼写错误了,正确的写法是referrer，意思为n.来路</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">url编码的数据都是以“%”为前缀，后面跟随两位的16进制数据</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">keyword=hello，包括这里的“=”</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;HTTP协议是基于C/S架构运行在TCP之上请求响应的应用层超文本传输协议&lt;/p&gt;
&lt;p&gt;协议（网络协议）：在同层之间有关通信的规则和约定的集合&lt;/p&gt;
&lt;p&gt;C/S架构：它是客户端和服务器之间所签订的协议&lt;/p&gt;
&lt;h1 id=&quot;工作过程&quot;&gt;&lt;a href=&quot;#工作过程&quot; class=&quot;headerlink&quot; title=&quot;工作过程&quot;&gt;&lt;/a&gt;工作过程&lt;/h1&gt;&lt;p&gt;典型的HTTP事务处理过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端与服务器建立链接&lt;/li&gt;
&lt;li&gt;客户端向服务器提出请求&lt;/li&gt;
&lt;li&gt;服务器接受请求，根据请求返回相应的文件作为应答&lt;/li&gt;
&lt;li&gt;客户与服务器关闭连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C/S架构的HTTP连接是一种一次性连接，它限制每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭连接，下次请求再重新建立连接。&lt;/p&gt;
    
    </summary>
    
      <category term="学习之路" scheme="https://lianblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="计算机网络" scheme="https://lianblogs.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java基础—内部类</title>
    <link href="https://lianblogs.cn/2019/07/04/Java%E5%9F%BA%E7%A1%80_%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://lianblogs.cn/2019/07/04/Java基础_内部类/</id>
    <published>2019-07-04T03:11:32.000Z</published>
    <updated>2019-08-21T18:02:25.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>可以将一个类的定义放在另一个类的定义内部</p><p>内部类的基本形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>内部类拥有对其外部类所有成员的访问权限<br>其原理是：<br>当外部类对象创建了一个内部类对象，此内部类会秘密的获取一个指向外部类对象的引用。之后访问外部类成员时，就可以用那个引用来访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String s = <span class="string">"Outer.s"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Inner.say()"</span>);</span><br><span class="line">System.out.println(s);<span class="comment">// 内部类可以访问外部类的所有成员</span></span><br><span class="line">getInner();<span class="comment">// 内部类调用外部类方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">Inner inner = out.getInner();</span><br><span class="line">inner.say();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Inner.say()</span></span><br><span class="line"><span class="comment">Outer.s</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="this与-new"><a href="#this与-new" class="headerlink" title=".this与.new"></a>.this与.new</h1><p>.this用来生成对外部类对象的引用</p><p>.new用来创建某个内部类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisAndNew</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Outer.say()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ThisAndNew <span class="title">getOutClazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ThisAndNew.<span class="keyword">this</span>;<span class="comment">// 返回的是ThisAndNew</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThisAndNew tan = <span class="keyword">new</span> ThisAndNew();</span><br><span class="line">ThisAndNew.Inner in = tan.new Inner();<span class="comment">// 返回的是Inner</span></span><br><span class="line">in.getOutClazz().say();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Outer.say()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure><h1 id="内部类的创建"><a href="#内部类的创建" class="headerlink" title="内部类的创建"></a>内部类的创建</h1><p>两种方式：</p><p>A:通过方法创建内部类的示例</p><p>B:通过 .new 创建内部类</p><p>都必须通过外部类来创建内部类。（有特殊情况，后文会提及）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Out2</span> </span>&#123;</span><br><span class="line">Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner1 = out.getInner(); <span class="comment">// 通过方法创建内部类的实例</span></span><br><span class="line">Outer.Inner inner2 = out.new Inner(); <span class="comment">// 通过 .new 创建内部类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类的形式"><a href="#内部类的形式" class="headerlink" title="内部类的形式"></a>内部类的形式</h1><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>在类的局部（方法中）创建类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123; <span class="comment">// 局部内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inner类被嵌入if语句中，这并不是说该类的创建是有条件的，它其实已经与别的类一起编译过了。但是在类之外它是不可用的；除此之外和普通类一样。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>在需要一个对象的时候临时创建一个没有名字的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">Person per = p.person(); <span class="comment">// 返回的是Person</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类的实质是创建一个继承/实现Person的匿名内部类的对象<br>证明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">Person per = p.person(); <span class="comment">// 返回的是Person</span></span><br><span class="line"></span><br><span class="line">System.out.println(per.getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Person constructor Person()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Person constructor Person()</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure><p>会在return new Person();时会先加载父类<br>甚至是可以指定构造器的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">30</span>) &#123;&#125;; <span class="comment">// 决定使用有参或无参构造器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">Person per = p.person(); <span class="comment">// 返回的是Person</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"age:"</span>+per.getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 无参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Person constructor Person()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">"Person constructor Person(int age)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Person constructor Person()</span></span><br><span class="line"><span class="comment">age:30</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure><p>在return new Person(30)可以指定使用有参或无参构造器<br>如果想在内部类中使用外部参数<br> 从内部类中访问本地变量i; 需要被声明为最终类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//! public Person person(int i) &#123;//会在编译时候报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person() &#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> d = i;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在匿名内部类中不能重载构造器</p><h1 id="特殊的内部类——嵌套类"><a href="#特殊的内部类——嵌套类" class="headerlink" title="特殊的内部类——嵌套类"></a>特殊的内部类——嵌套类</h1><p>前面说过内部类都需要用外部类来创建，但凡是都有例外<br>因为不需要与外部类有联系就可以及那个内部类声明为static，这种类就被称为嵌套类。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>A：创建嵌套类对象，并不需要其外部类对象</p><p>B：不能从嵌套类的对象中访问非静态的外部类对象。（直观的现象就是不能用this来引用外部类。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="comment">//! NestedClass nc = NestedClass.this; </span></span><br><span class="line">        <span class="comment">//不能从嵌套类的对象中访问非静态的外部类对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Inner i = <span class="keyword">new</span> Inner();<span class="comment">//创建嵌套类对象，并不需要其外部类对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="特殊位置的内部类"><a href="#特殊位置的内部类" class="headerlink" title="特殊位置的内部类"></a>特殊位置的内部类</h1><h2 id="接口中的内部类"><a href="#接口中的内部类" class="headerlink" title="接口中的内部类"></a>接口中的内部类</h2><p>在接口内部中是不能放任何代码的，但嵌套类是可以作为接口的一部分的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedClassInIngerface</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//在内部类中实现外围的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">NestedClassInIngerface</span></span>&#123;<span class="comment">//在接口中任何类都是自动public和static的</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Inner implements NestedClassInIngerface.say()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">i.say();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Inner implements NestedClassInIngerface.say()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure><p><strong>在接口中任何类都是自动public和static的</strong></p><p>在内部类中甚至可以实现外围的接口</p><h2 id="多层嵌套的内部类"><a href="#多层嵌套的内部类" class="headerlink" title="多层嵌套的内部类"></a>多层嵌套的内部类</h2><p>一个内部类无论嵌套多少层都可以访问他的外部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedClazz</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String a = <span class="string">"a"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//可以拿到外部类的外部类成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">NestedClazz nc = <span class="keyword">new</span> NestedClazz();</span><br><span class="line">NestedClazz.A na = nc.new A();</span><br><span class="line">NestedClazz.A.B nab = na.new B();<span class="comment">//没有class.new.new这种语法，我试过了0-0</span></span><br><span class="line">System.out.println(nab.getA());</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//~</span></span><br></pre></td></tr></table></figure><h1 id="内部类的用处"><a href="#内部类的用处" class="headerlink" title="内部类的用处"></a>内部类的用处</h1><h2 id="实现“多重继承”"><a href="#实现“多重继承”" class="headerlink" title="实现“多重继承”"></a>实现“多重继承”</h2><p>在需要实现两个非接口的类（类或抽象类）时，就需要用到内部类来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function">B <span class="title">makeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> B() &#123;&#125;;<span class="comment">//相当于继承了B</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepetitionExtends</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">C c = <span class="keyword">new</span> C();</span><br><span class="line">useA(c);</span><br><span class="line">useB(c.makeB());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“多重继承”说的只是形式上的，不是真正意义上继承。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;可以将一个类的定义放在另一个类的定义内部&lt;/p&gt;
&lt;p&gt;内部类的基本形式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h1&gt;&lt;p&gt;内部类拥有对其外部类所有成员的访问权限&lt;br&gt;其原理是：&lt;br&gt;当外部类对象创建了一个内部类对象，此内部类会秘密的获取一个指向外部类对象的引用。之后访问外部类成员时，就可以用那个引用来访问。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Outer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String s = &lt;span class=&quot;string&quot;&gt;&quot;Outer.s&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Inner &lt;span class=&quot;title&quot;&gt;getInner&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Inner();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Inner&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Inner.say()&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.out.println(s);&lt;span class=&quot;comment&quot;&gt;// 内部类可以访问外部类的所有成员&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			getInner();&lt;span class=&quot;comment&quot;&gt;// 内部类调用外部类方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Outer out = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Outer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Inner inner = out.getInner();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		inner.say();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;/*Output:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;Inner.say()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;Outer.s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//~&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="学习之路" scheme="https://lianblogs.cn/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Java" scheme="https://lianblogs.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ssss</title>
    <link href="https://lianblogs.cn/2019/07/04/test/"/>
    <id>https://lianblogs.cn/2019/07/04/test/</id>
    <published>2019-07-03T17:16:04.000Z</published>
    <updated>2019-07-03T18:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="test" scheme="https://lianblogs.cn/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Go</title>
    <link href="https://lianblogs.cn/2019/07/02/hello/"/>
    <id>https://lianblogs.cn/2019/07/02/hello/</id>
    <published>2019-07-02T13:29:10.000Z</published>
    <updated>2019-07-03T17:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start!!!"></a>Start!!!</h2><p>一时看一时爽，一直看一直爽！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start!!!&quot;&gt;&lt;/a&gt;Start!!!&lt;/h2&gt;&lt;p&gt;一时看一时爽，一直看一直爽！&lt;/p&gt;

      
    
    </summary>
    
      <category term="hexo博客" scheme="https://lianblogs.cn/categories/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="test" scheme="https://lianblogs.cn/tags/test/"/>
    
  </entry>
  
</feed>
